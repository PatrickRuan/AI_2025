<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D → 2D 攝影機拍攝模擬（完全離線單檔版 / v3）</title>
  <style>
    *{box-sizing:border-box}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Noto Sans TC','PingFang TC',sans-serif;color:#e8eaed;background:#0b0d10}
    header{padding:12px 16px;border-bottom:1px solid #222}
    h1{font-size:18px;margin:0 0 4px}
    #panel{display:flex;gap:12px;align-items:center;flex-wrap:wrap;padding:8px 12px;border-bottom:1px solid #222}
    #panel label{display:flex;gap:6px;align-items:center;font-size:14px}
    #panel input[type=range]{width:160px}
    #panel .hint{opacity:.7;margin-left:8px}
    main{display:flex;height:calc(100vh - 168px);gap:8px;padding:8px}
    .pane{flex:1;position:relative;border:1px solid #222;border-radius:8px;overflow:hidden;background:#0f1115}
    canvas{width:100%;height:100%;display:block}
    .badge{position:absolute;left:8px;top:8px;font-size:12px;opacity:.75}
    .overlay{position:absolute;inset:0;pointer-events:none}
  </style>
</head>
<body tabindex="0">
  <header>
    <h1>3D → 2D 攝影機拍攝模擬（完全離線單檔版 / v3）</h1>
    <p>左：3D 編輯視角（拖曳旋轉；顯示拍攝相機位置與視錐）｜右：攝影機預覽（受控制面板影響）</p>
  </header>

  <section id="panel">
    <label>鏡頭大小
      <select id="shotSize">
        <option>極近鏡 (ECU)</option>
        <option>近鏡 (CU)</option>
        <option selected>中景 (MS)</option>
        <option>中遠景 (MLS)</option>
        <option>遠景 (LS)</option>
      </select>
    </label>
    <label>角度
      <select id="angle">
        <option selected>平視 (Eye-level)</option>
        <option>仰角 (Low angle)</option>
        <option>俯角 (High angle)</option>
      </select>
    </label>
    <label>水平環繞 (°)
      <input id="yaw" type="range" min="-180" max="180" step="1" value="20">
      <span id="yawVal">20</span>
    </label>
    <label>視角/焦距 (FOV)
      <input id="fov" type="range" min="20" max="75" step="1" value="35">
      <span id="fovVal">35</span>
    </label>
    <label>對焦高度
      <input id="focus" type="range" min="0.6" max="1.6" step="0.01" value="1.1">
      <span id="focusVal">1.10</span>
    </label>
    <label><input id="keepSize" type="checkbox"> 保持主角大小（推拉變焦）</label>
    <label><input id="helper" type="checkbox" checked> 顯示攝影機外框/視錐</label>
    <label><input id="guides" type="checkbox" checked> 預覽疊加構圖線（九宮格/安全框）</label>
    <span class="hint">滑鼠拖曳左側可旋轉；快捷鍵：1 近鏡、2 中景、3 遠景（鍵盤上排或數字小鍵都可）</span>
  </section>

  <main>
    <div class="pane">
      <div class="badge">3D 編輯視角</div>
      <canvas id="editor" tabindex="0"></canvas>
      <canvas id="editorOverlay" class="overlay"></canvas>
    </div>
    <div class="pane">
      <div class="badge">攝影機預覽</div>
      <canvas id="preview" tabindex="0"></canvas>
      <canvas id="previewOverlay" class="overlay"></canvas>
    </div>
  </main>

<script>
/* === Minimal 3D math (no external libs) === */
function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
function sub(a,b){return [a[0]-b[0],a[1]-b[1],a[2]-b[2]];}
function add(a,b){return [a[0]+b[0],a[1]+b[1],a[2]+b[2]];}
function mul(a,s){return [a[0]*s,a[1]*s,a[2]*s];}
function cross(a,b){return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];}
function norm(a){const l=Math.hypot(a[0],a[1],a[2]);return [a[0]/l,a[1]/l,a[2]/l];}
function mulVec(m,v){
  return [
    m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12]*v[3],
    m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13]*v[3],
    m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14]*v[3],
    m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]*v[3],
  ];
}
function mat4Mul(a,b){
  const o=new Array(16).fill(0);
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)for(let k=0;k<4;k++)o[r*4+c]+=a[r*4+k]*b[k*4+c];
  return o;
}
function lookAt(eye, target, up=[0,1,0]){
  const z = norm(sub(eye,target));
  const x = norm(cross(up,z));
  const y = cross(z,x);
  return [ x[0],y[0],z[0],0,  x[1],y[1],z[1],0,  x[2],y[2],z[2],0,  -dot(x,eye),-dot(y,eye),-dot(z,eye),1 ];
}
function perspective(fovDeg, aspect, near, far){
  const f=1/Math.tan((fovDeg*Math.PI/180)/2);
  const nf=1/(near-far);
  return [f/aspect,0,0,0, 0,f,0,0,  0,0,(far+near)*nf,-1,  0,0,(2*far*near)*nf,0];
}
function project(p, vp, w, h){
  const v=mulVec(vp,[p[0],p[1],p[2],1]);
  if(v[3]===0) return null;
  const ndc=[v[0]/v[3], v[1]/v[3], v[2]/v[3]];
  return [ (ndc[0]*0.5+0.5)*w, (-ndc[1]*0.5+0.5)*h, ndc[2] ];
}

/* === build meshes === */
function buildSphere(radius=0.45, seg=16, rings=12, yOffset=1.3){
  const tris=[];
  for(let i=0;i<rings;i++){
    const th1=(i/rings)*Math.PI, th2=((i+1)/rings)*Math.PI;
    for(let j=0;j<seg;j++){
      const ph1=(j/seg)*2*Math.PI, ph2=((j+1)/seg)*2*Math.PI;
      const p=(th,ph)=>[ radius*Math.sin(th)*Math.cos(ph), radius*Math.cos(th)+yOffset, radius*Math.sin(th)*Math.sin(ph) ];
      const a=p(th1,ph1), b=p(th1,ph2), c=p(th2,ph2), d=p(th2,ph1);
      tris.push([a,b,c],[a,c,d]);
    }
  }
  return tris;
}
function buildCapsule(r=0.6, h=1.2, seg=16, rings=10){
  const tris=[];
  const half=h/2;
  for(let j=0;j<seg;j++){
    const ph1=(j/seg)*2*Math.PI, ph2=((j+1)/seg)*2*Math.PI;
    const x1=Math.cos(ph1)*r, z1=Math.sin(ph1)*r;
    const x2=Math.cos(ph2)*r, z2=Math.sin(ph2)*r;
    const a=[x1,-half,z1], b=[x2,-half,z2], c=[x2, half,z2], d=[x1, half,z1];
    tris.push([a,b,c],[a,c,d]);
  }
  for(const top of [true,false]){
    for(let i=0;i<rings;i++){
      const th1=(i/rings)*(Math.PI/2), th2=((i+1)/rings)*(Math.PI/2);
      for(let j=0;j<seg;j++){
        const ph1=(j/seg)*2*Math.PI, ph2=((j+1)/seg)*2*Math.PI;
        const s=(th,ph)=>[ r*Math.sin(th)*Math.cos(ph), (top?half:-half)+(top?Math.cos(th):-Math.cos(th))*r, r*Math.sin(th)*Math.sin(ph) ];
        const A=s(th1,ph1), B=s(th1,ph2), C=s(th2,ph2), D=s(th2,ph1);
        if(top) tris.push([A,B,C],[A,C,D]); else tris.push([D,C,B],[D,B,A]);
      }
    }
  }
  return tris;
}

const bodyTris = buildCapsule(0.6,1.2,16,10);
const headTris = buildSphere(0.45,16,12,1.3);

/* === drawing === */
function drawScene(ctx, w, h, camEye, camTarget, fovDeg){
  ctx.clearRect(0,0,w,h);
  // brighter grid
  ctx.strokeStyle='#48505a';
  ctx.lineWidth=1;
  const mvp = mat4Mul(lookAt(camEye, camTarget), perspective(fovDeg, w/h, 0.1, 200));
  for(let i=-12;i<=12;i++){
    const a=project([i, -1, -14], mvp, w, h);
    const b=project([i, -1,  14], mvp, w, h);
    const c=project([-14, -1, i], mvp, w, h);
    const d=project([ 14, -1, i], mvp, w, h);
    if(a&&b){ctx.beginPath();ctx.moveTo(a[0],a[1]);ctx.lineTo(b[0],b[1]);ctx.stroke();}
    if(c&&d){ctx.beginPath();ctx.moveTo(c[0],c[1]);ctx.lineTo(d[0],d[1]);ctx.stroke();}
  }

  const lightDir = norm([-0.6,1.0,-0.4]);
  function shadeTri(tri, color){
    const z = tri.map(p=>mulVec(mvp,[p[0],p[1],p[2],1])[2]).reduce((a,b)=>a+b,0)/3;
    const n = norm(cross(sub(tri[1],tri[0]), sub(tri[2],tri[0])));
    const ndotl = Math.max(0, dot(n,lightDir));
    return {tri,z,lit:ndotl, col:color};
  }

  let all=[];
  const bodyCol=[255,136,68], headCol=[255,221,194];
  bodyTris.forEach(t=>all.push(shadeTri(t,bodyCol)));
  headTris.forEach(t=>all.push(shadeTri(t,headCol)));
  all.sort((A,B)=>B.z-A.z);

  for(const o of all){
    const a=project(o.tri[0], mvp, w, h);
    const b=project(o.tri[1], mvp, w, h);
    const c=project(o.tri[2], mvp, w, h);
    if(!a||!b||!c) continue;
    ctx.beginPath();
    ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.lineTo(c[0],c[1]); ctx.closePath();
    const alpha = 0.35 + 0.65*o.lit;
    ctx.fillStyle = `rgba(${o.col[0]},${o.col[1]},${o.col[2]},${alpha})`;
    ctx.fill();
  }

  return mvp;
}

// helpers on editor view (shot camera)
function drawShotHelpersOnEditor(ctx, w, h, editorEye, editorTarget, shotEye, shotTarget, fovDeg, show){
  if(!show) return;
  const mvpE = mat4Mul(lookAt(editorEye, editorTarget), perspective(55, w/h, 0.1, 200));

  // camera position
  const p = project(shotEye, mvpE, w, h);
  if(p){ ctx.fillStyle='#88c1ff'; ctx.beginPath(); ctx.arc(p[0],p[1],5,0,Math.PI*2); ctx.fill(); }

  // line to target
  const t = project(shotTarget, mvpE, w, h);
  if(p && t){ ctx.strokeStyle='#88c1ff'; ctx.beginPath(); ctx.moveTo(p[0],p[1]); ctx.lineTo(t[0],t[1]); ctx.stroke(); }

  // frustum edges
  const fwd = norm(sub(shotTarget, shotEye));
  const up=[0,1,0];
  const right = norm(cross(fwd, up));
  const trueUp = norm(cross(right, fwd));
  const aspect = w/h;
  const halfV = Math.tan((fovDeg*Math.PI/180)/2);
  const halfH = halfV * aspect;
  const nearLen = 1.0;
  const farLen = 6.0;

  const corners = [
    add(shotEye, add(mul(fwd, nearLen), add(mul(right, +halfH*nearLen), mul(trueUp, +halfV*nearLen)))),
    add(shotEye, add(mul(fwd, nearLen), add(mul(right, -halfH*nearLen), mul(trueUp, +halfV*nearLen)))),
    add(shotEye, add(mul(fwd, nearLen), add(mul(right, +halfH*nearLen), mul(trueUp, -halfV*nearLen)))),
    add(shotEye, add(mul(fwd, nearLen), add(mul(right, -halfH*nearLen), mul(trueUp, -halfV*nearLen)))),
  ];
  const farCorners = corners.map(c => add(shotEye, mul(sub(c, shotEye), farLen/nearLen)));

  ctx.strokeStyle='#557aab';
  for(const c of corners){
    const a = project(shotEye, mvpE, w, h);
    const b = project(c, mvpE, w, h);
    if(a&&b){ ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke(); }
  }
  // connect far plane
  function pl(i,j){
    const a = project(farCorners[i], mvpE, w, h);
    const b = project(farCorners[j], mvpE, w, h);
    if(a&&b){ ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke(); }
  }
  pl(0,1); pl(1,3); pl(3,2); pl(2,0);
}

/* === UI wiring === */
const ui = {
  shotSize: document.getElementById('shotSize'),
  angle: document.getElementById('angle'),
  yaw: document.getElementById('yaw'),
  yawVal: document.getElementById('yawVal'),
  fov: document.getElementById('fov'),
  fovVal: document.getElementById('fovVal'),
  focus: document.getElementById('focus'),
  focusVal: document.getElementById('focusVal'),
  keepSize: document.getElementById('keepSize'),
  helper: document.getElementById('helper'),
  guides: document.getElementById('guides')
};
const SHOT_SIZES = { '極近鏡 (ECU)':0.4, '近鏡 (CU)':0.8, '中景 (MS)':1.6, '中遠景 (MLS)':2.4, '遠景 (LS)':4.0 };
const ANGLES = { '平視 (Eye-level)':0, '仰角 (Low angle)':-15, '俯角 (High angle)':20 };

const editorCanvas = document.getElementById('editor');
const previewCanvas = document.getElementById('preview');
const editorOverlay = document.getElementById('editorOverlay');
const previewOverlay = document.getElementById('previewOverlay');
const ectx = editorCanvas.getContext('2d');
const pctx = previewCanvas.getContext('2d');
const eox = editorOverlay.getContext('2d');
const pox = previewOverlay.getContext('2d');

function resize(){
  const canvases=[editorCanvas, previewCanvas, editorOverlay, previewOverlay];
  canvases.forEach(canvas=>{
    const rect=canvas.getBoundingClientRect();
    canvas.width=rect.width*window.devicePixelRatio;
    canvas.height=rect.height*window.devicePixelRatio;
    const ctx=canvas.getContext('2d');
    ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
  });
}
window.addEventListener('resize', resize);
resize();

// editor orbit
let edYaw=0.9, edPitch=0.4, dragging=false, lastX=0, lastY=0;
editorCanvas.addEventListener('mousedown', e=>{dragging=true; lastX=e.clientX; lastY=e.clientY; editorCanvas.focus();});
window.addEventListener('mouseup', ()=>dragging=false);
window.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx=(e.clientX-lastX)*0.01, dy=(e.clientY-lastY)*0.01;
  edYaw += dx; edPitch = Math.max(-1.2, Math.min(1.2, edPitch+dy));
  lastX=e.clientX; lastY=e.clientY;
});

function applyShot(){
  ui.yawVal.textContent = ui.yaw.value;
  ui.fovVal.textContent = ui.fov.value;
  ui.focusVal.textContent = Number(ui.focus.value).toFixed(2);
}
['change','input'].forEach(evt=>{
  ui.shotSize.addEventListener(evt, applyShot);
  ui.angle.addEventListener(evt, applyShot);
  ui.yaw.addEventListener(evt, applyShot);
  ui.fov.addEventListener(evt, applyShot);
  ui.focus.addEventListener(evt, applyShot);
  ui.keepSize.addEventListener(evt, applyShot);
  ui.helper.addEventListener(evt, applyShot);
  ui.guides.addEventListener(evt, applyShot);
});
applyShot();

// keyboard shortcuts (global; top row & numpad)
window.addEventListener('keydown', (e)=>{
  const code=e.code || '';
  if (['Digit1','Numpad1'].includes(code) || e.key==='1'){ ui.shotSize.value='近鏡 (CU)'; applyShot(); }
  if (['Digit2','Numpad2'].includes(code) || e.key==='2'){ ui.shotSize.value='中景 (MS)'; applyShot(); }
  if (['Digit3','Numpad3'].includes(code) || e.key==='3'){ ui.shotSize.value='遠景 (LS)'; applyShot(); }
});

const BASE_FOV = 35; // reference for keep-size dolly zoom
function computeShotEye(target, yawDeg, pitchDeg, dist, fovDeg, keepSize){
  let finalDist = dist*2.2;
  if (keepSize){
    const ratio = Math.tan((fovDeg*Math.PI/180)/2) / Math.tan((BASE_FOV*Math.PI/180)/2);
    finalDist = finalDist * ratio; // dolly out when FOV increases
  }
  const yaw = (yawDeg||0) * Math.PI/180;
  const pitch = (pitchDeg||0) * Math.PI/180;
  return [
    target[0] + Math.sin(yaw)*Math.cos(pitch)*finalDist,
    target[1] + Math.sin(pitch)*finalDist,
    target[2] + Math.cos(yaw)*Math.cos(pitch)*finalDist
  ];
}

function drawGuides(ctx, w, h){
  ctx.clearRect(0,0,w,h);
  if(!ui.guides.checked) return;
  ctx.strokeStyle='rgba(255,255,255,0.12)';
  ctx.lineWidth=1;
  // thirds
  const x1=w/3, x2=2*w/3, y1=h/3, y2=2*h/3;
  ctx.beginPath(); ctx.moveTo(x1,0); ctx.lineTo(x1,h); ctx.moveTo(x2,0); ctx.lineTo(x2,h); ctx.moveTo(0,y1); ctx.lineTo(w,y1); ctx.moveTo(0,y2); ctx.lineTo(w,y2); ctx.stroke();
  // safe frame (90%)
  const sx=w*0.05, sy=h*0.05;
  ctx.strokeStyle='rgba(255,255,255,0.16)';
  ctx.strokeRect(sx, sy, w-2*sx, h-2*sy);
}

function loop(){
  // editor camera
  const editorEye = [
    Math.sin(edYaw)*Math.cos(edPitch)*6,
    Math.sin(edPitch)*6 + 1.0,
    Math.cos(edYaw)*Math.cos(edPitch)*6
  ];
  const editorTarget = [0,0.7,0];
  drawScene(ectx, editorCanvas.width/window.devicePixelRatio, editorCanvas.height/window.devicePixelRatio, editorEye, editorTarget, 55);

  // shot camera from UI
  const dist = SHOT_SIZES[ui.shotSize.value];
  const pitch = ANGLES[ui.angle.value] || 0;
  const yaw = Number(ui.yaw.value)||0;
  const shotTarget = [0, Number(ui.focus.value), 0];
  const shotEye = computeShotEye(shotTarget, yaw, pitch, dist, Number(ui.fov.value), ui.keepSize.checked);

  // draw shot on preview
  drawScene(pctx, previewCanvas.width/window.devicePixelRatio, previewCanvas.height/window.devicePixelRatio, shotEye, shotTarget, Number(ui.fov.value));
  drawGuides(pox, previewCanvas.width/window.devicePixelRatio, previewCanvas.height/window.devicePixelRatio);

  // overlay helpers on editor if toggled
  const w = editorCanvas.width/window.devicePixelRatio;
  const h = editorCanvas.height/window.devicePixelRatio;
  const eox2 = eox;
  eox2.clearRect(0,0,w,h);
  if (ui.helper.checked) {
    drawShotHelpersOnEditor(eox2, w, h, editorEye, editorTarget, shotEye, shotTarget, Number(ui.fov.value), true);
  }

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
